<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ´»å‹•æ’ä½å¤§å¸« (Builder)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        body { font-family: 'Noto Sans TC', sans-serif; overflow: hidden; }
        
        #floorCanvas { background-color: #f8fafc; cursor: grab; overflow: hidden; }
        #floorCanvas:active { cursor: grabbing; }
        #transformLayer {
            transform-origin: 0 0; position: absolute; top: 50%; left: 50%;
            width: 0; height: 0; overflow: visible;
        }
        /* Infinite Grid & Axes */
        .grid-background {
            position: absolute; top: -20000px; left: -20000px; width: 40000px; height: 40000px;
            background-image: linear-gradient(#e2e8f0 1px, transparent 1px), linear-gradient(90deg, #e2e8f0 1px, transparent 1px);
            background-size: 40px 40px;
            background-position: 20000px 20000px; /* Align grid to 0,0 */
            pointer-events: none; z-index: -10;
        }
        .axis-line { position: absolute; background: #94a3b8; pointer-events: none; z-index: -5; }
        .axis-x { top: 0; left: -20000px; width: 40000px; height: 2px; }
        .axis-y { left: 0; top: -20000px; height: 40000px; width: 2px; }
        
        /* Center Label */
        .origin-label {
            position: absolute; top: 2px; left: 4px; font-size: 10px; color: #64748b; pointer-events: none; z-index: -4;
        }

        .draggable-item { position: absolute; user-select: none; transition: box-shadow 0.2s; }
        .draggable-item:hover { z-index: 50; }
        
        /* Table Styles - Shared */
        .table-node {
            background: white; border: 2px solid #cbd5e1;
            display: flex; flex-direction: column; overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); /* Smooth transition between modes */
        }
        /* Main Table Variant */
        .table-node.type-main {
            background-color: #fee2e2; border-color: #ef4444; color: #b91c1c;
        }
        .table-node.type-main .guest-chip { border-color: #fca5a5; }

        .table-node.drag-over { border-color: #3b82f6; background-color: #eff6ff; }

        /* Mode: Assign (Large Rect) */
        .table-node.mode-assign {
            border-radius: 1rem;
        }

        /* Mode: Layout (Small Circle) */
        .table-node.mode-layout {
            border-radius: 50%;
            border-color: #f97316; /* Orange border like output */
            background-color: #fff7ed;
            align-items: center; justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .table-node.mode-layout.type-main {
            border-color: #ef4444; background-color: #fee2e2;
        }
        .table-node.mode-layout:hover {
            transform: scale(1.05);
            border-color: #ea580c;
        }

        /* Objects */
        .obj-stage {
            background: #3b82f6; color: white; display: flex; align-items: center; justify-content: center;
            font-weight: bold; border-radius: 4px; opacity: 0.9; box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        .obj-label {
            background: #e2e8f0; border: 1px solid #94a3b8; color: #475569; padding: 5px 15px;
            border-radius: 999px; font-weight: bold; display: flex; align-items: center; justify-content: center;
        }

        .guest-chip { cursor: grab; transition: all 0.2s; user-select: none; }
        .guest-chip:active { cursor: grabbing; transform: scale(1.05); opacity: 0.8; }
        .guest-chip.dragging { opacity: 0.5; }

        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        #modalOverlay.hidden { display: none; }

        /* Selection & Marquee */
        .selected-obj { outline: 2px solid #3b82f6; outline-offset: 2px; z-index: 60 !important; }
        #selectionMarquee { position: absolute; border: 1px solid #3b82f6; background: rgba(59, 130, 246, 0.2); display: none; z-index: 9999; pointer-events: none; }

        /* Print Styles (Vector PDF) */
        @media print {
            @page { size: landscape; margin: 5mm; }
            body { 
                margin: 0 !important; padding: 0 !important; 
                width: 100vw; height: 100vh; 
                display: flex !important; justify-content: center; align-items: center;
                background: white !important;
            }
            body > *:not(#print-container) { display: none !important; }
            #print-container { display: block !important; width: 297mm; height: 210mm; position: relative; overflow: hidden; }
            #print-content { position: absolute; top: 50%; left: 50%; transform-origin: center center; }
            .print-color-adjust {
                -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;
            }
        }
    </style>
</head>
<body class="h-screen flex flex-col bg-gray-50 text-gray-800">

    <header class="bg-white border-b border-gray-200 h-14 flex items-center justify-between px-4 shadow-sm z-20 flex-shrink-0">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center text-white">
                <i class="fa-solid fa-layer-group"></i>
            </div>
            <div>
                <h1 class="font-bold text-gray-800 leading-tight">æ´»å‹•æ’ä½å¤§å¸«</h1>
                <p class="text-[10px] text-gray-400" id="saveStatus">Ready</p>
            </div>
        </div>
        
        <div class="flex items-center gap-2">
            <!-- History Controls -->
            <div class="bg-gray-100 p-1 rounded-lg border border-gray-200 flex gap-1 mr-2">
                <button onclick="undo()" id="btn-undo" class="px-3 py-1 text-xs font-bold rounded text-gray-400 cursor-not-allowed transition" disabled title="å¾©åŸ (Ctrl+Z)"><i class="fa-solid fa-rotate-left"></i></button>
                <button onclick="redo()" id="btn-redo" class="px-3 py-1 text-xs font-bold rounded text-gray-400 cursor-not-allowed transition" disabled title="é‡åš (Ctrl+Y)"><i class="fa-solid fa-rotate-right"></i></button>
            </div>

            <!-- Tool Toggle -->
            <div class="bg-gray-100 p-1 rounded-lg border border-gray-200 flex gap-1 mr-2">
                <button onclick="setTool('select')" id="btn-tool-select" class="px-3 py-1 text-xs font-bold rounded shadow bg-white text-blue-600 transition" title="æ¡†é¸æ¨¡å¼"><i class="fa-solid fa-vector-square"></i></button>
                <button onclick="setTool('pan')" id="btn-tool-pan" class="px-3 py-1 text-xs font-bold rounded text-gray-500 hover:bg-gray-200 transition" title="æ‹–æ›³ç•«å¸ƒ"><i class="fa-solid fa-hand"></i></button>
            </div>

            <!-- View Toggle -->
            <div class="bg-gray-100 p-1 rounded-lg border border-gray-200 flex gap-1 mr-2">
                <button onclick="setViewMode('assign')" id="btn-view-assign" class="px-3 py-1 text-xs font-bold rounded shadow bg-white text-blue-600 transition">
                    <i class="fa-solid fa-users-rectangle"></i> æ’ä½ (å¤§)
                </button>
                <button onclick="setViewMode('layout')" id="btn-view-layout" class="px-3 py-1 text-xs font-bold rounded text-gray-500 hover:bg-gray-200 transition">
                    <i class="fa-solid fa-circle-nodes"></i> ä½ˆç½® (å°)
                </button>
                <button onclick="toggleSpread()" id="btn-spread" class="ml-2 px-3 py-1 text-xs font-bold rounded bg-purple-100 text-purple-700 hover:bg-purple-200 transition hidden" title="è‡ªå‹•å°‡é‡ç–Šçš„åº§ä½æ¨é–‹ï¼Œä¸å½±éŸ¿å¯¦éš›ä½ˆç½®ä½ç½®">
                    <i class="fa-solid fa-arrows-left-right-to-line"></i> åˆ†æ•£
                </button>
            </div>

            <div class="flex items-center bg-gray-100 rounded-lg p-1 border border-gray-200 mr-2">
                <button onclick="zoomOut()" class="w-8 h-8 hover:bg-white rounded text-gray-600"><i class="fa-solid fa-minus"></i></button>
                <span id="zoomLevelDisplay" class="text-xs font-mono w-10 text-center text-gray-500">100%</span>
                <button onclick="zoomIn()" class="w-8 h-8 hover:bg-white rounded text-gray-600"><i class="fa-solid fa-plus"></i></button>
                <div class="w-[1px] h-4 bg-gray-300 mx-1"></div>
                <button onclick="autoFitZoom()" class="px-2 h-8 hover:bg-white rounded text-gray-600 text-xs font-bold"><i class="fa-solid fa-expand"></i></button>
            </div>

            <button onclick="resetData()" class="bg-red-50 text-red-600 hover:bg-red-100 px-3 py-1.5 rounded text-sm transition" title="æ¸…ç©º"><i class="fa-solid fa-trash-can"></i></button>
            <div class="h-6 w-[1px] bg-gray-300 mx-1"></div>
            <button onclick="exportExcel()" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1.5 rounded shadow text-sm font-bold flex items-center gap-2"><i class="fa-solid fa-file-excel"></i> Excel</button>
            <button onclick="exportPDF()" id="btn-export-pdf" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1.5 rounded shadow text-sm font-bold flex items-center gap-2"><i class="fa-solid fa-file-pdf"></i> PDF</button>
            <button onclick="exportWebPackage()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1.5 rounded shadow text-sm font-bold flex items-center gap-2"><i class="fa-solid fa-globe"></i> æ‰“åŒ…ç¶²é </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <aside class="w-80 bg-white border-r border-gray-200 flex flex-col shadow-lg z-10 flex-shrink-0">
            <div class="flex border-b border-gray-200 text-sm font-bold text-gray-500">
                <button onclick="switchTab('tab-guests')" id="btn-tab-guests" class="flex-1 py-3 text-blue-600 border-b-2 border-blue-600 bg-blue-50">äººå“¡åå–®</button>
                <button onclick="switchTab('tab-layout')" id="btn-tab-layout" class="flex-1 py-3 hover:text-gray-700 hover:bg-gray-50">å ´åœ°ä½ˆç½®</button>
            </div>

            <div id="tab-guests" class="flex-1 flex flex-col overflow-hidden">
                <div class="p-3 border-b bg-gray-50 space-y-2">
                    <div class="relative">
                        <input type="text" id="defaultUnitInput" placeholder="é è¨­å–®ä½ (é¸å¡«)" class="w-full border rounded p-1.5 text-sm pl-7">
                        <i class="fa-solid fa-building absolute left-2 top-2 text-gray-400 text-xs"></i>
                    </div>
                    <div class="flex gap-2 text-[10px] bg-white p-1 rounded border text-gray-600">
                        <span class="font-bold pl-1 text-gray-400">è¼¸å…¥æ¨¡å¼:</span>
                        <label class="flex items-center gap-1 cursor-pointer hover:text-blue-600"><input type="radio" name="inputMode" value="name" checked> å§“å</label>
                        <label class="flex items-center gap-1 cursor-pointer hover:text-blue-600"><input type="radio" name="inputMode" value="unit"> å–®ä½</label>
                    </div>
                    <textarea id="guestInput" rows="3" class="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="è¼¸å…¥åå–®... (æ”¯æ´: è²¡å‹™éƒ¨ 5)"></textarea>
                    <button onclick="parseGuests()" class="w-full bg-gray-800 text-white text-sm py-1.5 rounded hover:bg-black transition">åŠ å…¥åå–®</button>
                    <div class="flex justify-between text-xs text-gray-500 pt-1">
                        <span>ç¸½è¨ˆ: <b id="totalCount">0</b></span>
                        <span class="text-green-600">å·²æ’: <b id="seatedCount">0</b></span>
                        <span class="text-red-600">æœªæ’: <b id="unseatedCount">0</b></span>
                    </div>
                </div>
                <div class="bg-gray-100 p-1 text-xs text-center font-bold text-gray-500 shadow-inner">æœªå…¥å¸­æ¸…å–®</div>
                <div id="unseatedList" class="flex-1 overflow-y-auto p-2 space-y-1 bg-gray-50"></div>
            </div>

            <div id="tab-layout" class="hidden flex-1 flex flex-col overflow-y-auto p-4 space-y-4 bg-gray-50">
                <div class="bg-white p-3 rounded-lg border shadow-sm">
                    <h3 class="font-bold text-gray-700 text-sm mb-2"><i class="fa-solid fa-table-cells"></i> å¿«é€Ÿç”Ÿæˆ</h3>
                    <div class="grid grid-cols-3 gap-2 text-xs mb-2">
                        <input type="number" id="colsInput" value="4" class="border rounded p-1" title="æ©«æ’">
                        <input type="number" id="rowsInput" value="3" class="border rounded p-1" title="ç›´åˆ—">
                        <input type="number" id="gapInput" value="120" class="border rounded p-1" title="é–“è·">
                    </div>
                    <button onclick="generateGridTables()" class="w-full bg-blue-100 text-blue-700 text-sm py-1.5 rounded hover:bg-blue-200">ç”ŸæˆçŸ©é™£ (é©åˆä½ˆç½®æ¨¡å¼)</button>
                </div>
                <div class="bg-white p-3 rounded-lg border shadow-sm">
                    <h3 class="font-bold text-gray-700 text-sm mb-2"><i class="fa-solid fa-shapes"></i> åŠ å…¥ç‰©ä»¶</h3>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="addMapObject('table')" class="flex flex-col items-center p-2 border rounded hover:bg-gray-50 transition"><div class="w-8 h-8 rounded-full border-2 border-orange-400 bg-orange-50 mb-1"></div><span class="text-xs">åœ“æ¡Œ</span></button>
                        <button onclick="addMapObject('main-table')" class="flex flex-col items-center p-2 border rounded hover:bg-gray-50 transition"><div class="w-8 h-8 rounded-full border-2 border-red-400 bg-red-100 mb-1"></div><span class="text-xs">ä¸»æ¡Œ</span></button>
                        <button onclick="addMapObject('stage')" class="flex flex-col items-center p-2 border rounded hover:bg-gray-50 transition"><div class="w-12 h-6 bg-blue-500 rounded mb-1"></div><span class="text-xs">èˆå°</span></button>
                        <button onclick="addMapObject('label')" class="flex flex-col items-center p-2 border rounded hover:bg-gray-50 transition"><div class="w-12 h-6 bg-gray-200 border border-gray-400 rounded-full flex items-center justify-center text-[8px] mb-1">å…¥å£</div><span class="text-xs">æ¨™ç¤º</span></button>
                    </div>
                </div>
                <div class="text-xs text-gray-400 px-1">* å»ºè­°åˆ‡æ›è‡³ã€Œä½ˆç½® (å°)ã€æ¨¡å¼ä¾†æ’åˆ—æ¡Œå­ï¼Œä»¥ç²å¾—æœ€æº–ç¢ºçš„è¼¸å‡ºæ•ˆæœã€‚</div>
            </div>
        </aside>

        <main class="flex-1 relative bg-gray-200 overflow-hidden">
            <div id="floorCanvas" class="w-full h-full relative"><div id="transformLayer"></div></div>
            <div id="selectionMarquee"></div>
            <div class="absolute top-4 right-4 flex flex-col gap-2">
                <div class="bg-white/90 backdrop-blur p-2 rounded shadow-lg border text-xs">
                    <label class="flex items-center gap-2 cursor-pointer select-none">
                        <input type="checkbox" id="lockLayout" onchange="toggleLock()" class="accent-blue-600">
                        <span id="lockLabel">ğŸ”“ è§£é–ç·¨è¼¯ (å¯ç§»å‹•)</span>
                    </label>
                </div>
                <div class="bg-white/90 backdrop-blur p-2 rounded shadow-lg border text-xs">
                    <label class="flex items-center gap-2 cursor-pointer select-none">
                        <input type="checkbox" id="snapGrid" onchange="toggleSnap()" class="accent-blue-600">
                        <span>ğŸ“ å¸é™„æ ¼é»</span>
                    </label>
                </div>
            </div>
            
            <!-- Alignment Toolbar (Floating) -->
            <div id="alignToolbar" class="absolute bottom-8 left-1/2 transform -translate-x-1/2 bg-white/95 backdrop-blur shadow-xl border border-gray-300 rounded-full px-4 py-2 flex gap-3 z-50 hidden transition-all">
                <div class="flex gap-1 border-r pr-3 border-gray-300">
                    <button onclick="alignSelected('left')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="é å·¦å°é½Š"><i class="fa-solid fa-align-left"></i></button>
                    <button onclick="alignSelected('center-h')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="æ°´å¹³ç½®ä¸­"><i class="fa-solid fa-align-center"></i></button>
                    <button onclick="alignSelected('right')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="é å³å°é½Š"><i class="fa-solid fa-align-right"></i></button>
                </div>
                <div class="flex gap-1 border-r pr-3 border-gray-300">
                    <button onclick="alignSelected('top')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="é ä¸Šå°é½Š"><i class="fa-solid fa-align-justify fa-rotate-90"></i></button>
                    <button onclick="alignSelected('center-v')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="å‚ç›´ç½®ä¸­"><i class="fa-solid fa-align-center fa-rotate-90"></i></button>
                    <button onclick="alignSelected('bottom')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="é ä¸‹å°é½Š"><i class="fa-solid fa-align-left fa-rotate-90"></i></button>
                </div>
                <div class="flex gap-1">
                    <button onclick="distributeSelected('h')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="æ°´å¹³åˆ†ä½ˆ (ç­‰é–“è·)"><i class="fa-solid fa-ellipsis"></i></button>
                    <button onclick="distributeSelected('v')" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="å‚ç›´åˆ†ä½ˆ (ç­‰é–“è·)"><i class="fa-solid fa-ellipsis-vertical"></i></button>
                </div>
                <div class="flex gap-1 border-l pl-3 border-gray-300">
                    <button onclick="arrangeSelectedGrid()" class="p-1.5 hover:bg-blue-50 text-gray-600 hover:text-blue-600 rounded" title="çŸ©é™£æ’åˆ— (Grid)"><i class="fa-solid fa-border-all"></i></button>
                </div>
            </div>
        </main>
    </div>

    <div id="modalOverlay" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-lg p-5 w-80 shadow-2xl transform transition-all">
            <h3 class="font-bold text-lg mb-3">ä¿®æ”¹åç¨±</h3>
            <input type="text" id="modalInput" class="w-full border p-2 rounded mb-4 focus:ring-2 focus:ring-blue-500 outline-none">
            <div class="flex justify-end gap-2">
                <button onclick="closeModal()" class="px-4 py-2 text-gray-500 hover:bg-gray-100 rounded">å–æ¶ˆ</button>
                <button onclick="saveModal()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">ç¢ºå®š</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let mapObjects = []; 
        let guests = [];
        let appState = { scale: 1, panX: 0, panY: 0, locked: false, viewMode: 'assign', isSpread: false, toolMode: 'select', selectedIds: [], snapToGrid: false, isSpaceDown: false }; // 'assign' or 'layout'
        let editingObjectId = null;
        let historyStack = [];
        let redoStack = [];

        // Constants
        const SIZES = {
            table: {
                assign: { w: 240, h: 240 }, // Standard Table (Large)
                layout: { w: 80, h: 80 }    // Standard Table (Small)
            },
            'main-table': {
                assign: { w: 300, h: 300 }, // Main Table (Extra Large)
                layout: { w: 120, h: 120 }  // Main Table (Medium Circle)
            }
        };
        const ASSIGN_SCALE = 2.5; // Scale factor for Assign Mode

        document.addEventListener('DOMContentLoaded', () => {
            loadFromLocal();
            setupCanvasEvents();
            
            // ä¿®æ­£ï¼šåœ¨æ­¤è™•ç‚ºå´é‚Šæ¬„åŠ ä¸Šç›£è½å™¨
            const sidebar = document.getElementById('unseatedList');
            sidebar.addEventListener('dragover', e => e.preventDefault());
            sidebar.addEventListener('drop', e => dropGuest(e, null));

            renderAll();
            updateStats();

            // Keyboard Shortcuts for Undo/Redo
            window.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) redo();
                    else undo();
                } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                    e.preventDefault();
                    redo();
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    if (appState.selectedIds.length > 0) {
                        e.preventDefault();
                        deleteObject();
                    }
                } else if (e.code === 'Space' && !e.repeat) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    e.preventDefault();
                    appState.isSpaceDown = true;
                    document.getElementById('floorCanvas').style.cursor = 'grab';
                }
            });
            window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    appState.isSpaceDown = false;
                    const canvas = document.getElementById('floorCanvas');
                    canvas.style.cursor = appState.toolMode === 'pan' ? 'grab' : 'default';
                }
            });
        });

        // --- History System ---
        function recordState() {
            // Call this BEFORE making changes to mapObjects or guests
            const state = JSON.stringify({ mapObjects, guests });
            historyStack.push(state);
            if (historyStack.length > 50) historyStack.shift(); // Limit history
            redoStack = []; // Clear redo on new action
            updateHistoryButtons();
        }

        function undo() {
            if (historyStack.length === 0) return;
            const currentState = JSON.stringify({ mapObjects, guests });
            redoStack.push(currentState);
            
            const prevState = JSON.parse(historyStack.pop());
            mapObjects = prevState.mapObjects;
            guests = prevState.guests;
            
            renderAll(); updateStats(); saveToLocal(); updateHistoryButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const currentState = JSON.stringify({ mapObjects, guests });
            historyStack.push(currentState);
            
            const nextState = JSON.parse(redoStack.pop());
            mapObjects = nextState.mapObjects;
            guests = nextState.guests;
            
            renderAll(); updateStats(); saveToLocal(); updateHistoryButtons();
        }

        function updateHistoryButtons() {
            const btnUndo = document.getElementById('btn-undo');
            const btnRedo = document.getElementById('btn-redo');
            
            if (historyStack.length > 0) {
                btnUndo.disabled = false;
                btnUndo.classList.remove('text-gray-400', 'cursor-not-allowed');
                btnUndo.classList.add('text-gray-700', 'hover:bg-gray-200');
            } else {
                btnUndo.disabled = true;
                btnUndo.classList.add('text-gray-400', 'cursor-not-allowed');
                btnUndo.classList.remove('text-gray-700', 'hover:bg-gray-200');
            }

            if (redoStack.length > 0) {
                btnRedo.disabled = false;
                btnRedo.classList.remove('text-gray-400', 'cursor-not-allowed');
                btnRedo.classList.add('text-gray-700', 'hover:bg-gray-200');
            } else {
                btnRedo.disabled = true;
                btnRedo.classList.add('text-gray-400', 'cursor-not-allowed');
                btnRedo.classList.remove('text-gray-700', 'hover:bg-gray-200');
            }
        }

        // --- Tool Mode ---
        function setTool(mode) {
            appState.toolMode = mode;
            const btnSelect = document.getElementById('btn-tool-select');
            const btnPan = document.getElementById('btn-tool-pan');
            if (mode === 'select') {
                btnSelect.classList.add('shadow', 'bg-white', 'text-blue-600'); btnSelect.classList.remove('text-gray-500', 'hover:bg-gray-200');
                btnPan.classList.remove('shadow', 'bg-white', 'text-blue-600'); btnPan.classList.add('text-gray-500', 'hover:bg-gray-200');
            } else {
                btnPan.classList.add('shadow', 'bg-white', 'text-blue-600'); btnPan.classList.remove('text-gray-500', 'hover:bg-gray-200');
                btnSelect.classList.remove('shadow', 'bg-white', 'text-blue-600'); btnSelect.classList.add('text-gray-500', 'hover:bg-gray-200');
            }
        }

        // --- View Mode Logic ---
        function setViewMode(mode) {
            if (appState.viewMode === mode) return;

            if (mode === 'assign') {
                // Layout -> Assign: Scale Center relative to Origin (0,0)
                mapObjects.forEach(o => {
                    // 1. Current Center (Layout)
                    const cx = o.x + o.width / 2;
                    const cy = o.y + o.height / 2;
                    
                    o.ox = o.x; 
                    o.oy = o.y;

                    // 2. Update Dimensions
                    if (SIZES[o.type]) {
                        o.width = SIZES[o.type].assign.w;
                        o.height = SIZES[o.type].assign.h;
                    }

                    // 3. Scale Center
                    const newCx = cx * ASSIGN_SCALE;
                    const newCy = cy * ASSIGN_SCALE;

                    o.x = newCx - o.width / 2;
                    o.y = newCy - o.height / 2;
                });
            } else {
                // Assign -> Layout
                mapObjects.forEach(o => {
                    // 1. Current Center (Assign)
                    const cx = o.x + o.width / 2;
                    const cy = o.y + o.height / 2;

                    // 2. Target Center (Layout)
                    const newCx = cx / ASSIGN_SCALE;
                    const newCy = cy / ASSIGN_SCALE;

                    // 3. Update Dimensions
                    if (SIZES[o.type]) {
                        o.width = SIZES[o.type].layout.w;
                        o.height = SIZES[o.type].layout.h;
                    }

                    o.x = newCx - o.width / 2;
                    o.y = newCy - o.height / 2;

                    delete o.ox; delete o.oy;
                });
            }

            // ä½ˆç½®æ¨¡å¼é è¨­é–‹å•Ÿå¸é™„æ ¼é»
            if (mode === 'layout') {
                appState.snapToGrid = true;
                const cb = document.getElementById('snapGrid'); if(cb) cb.checked = true;
            }

            appState.viewMode = mode;
            
            // Update Buttons
            const btnAssign = document.getElementById('btn-view-assign');
            const btnLayout = document.getElementById('btn-view-layout');
            
            if(mode === 'assign') {
                btnAssign.classList.add('shadow', 'bg-white', 'text-blue-600');
                btnAssign.classList.remove('text-gray-500', 'hover:bg-gray-200');
                btnLayout.classList.remove('shadow', 'bg-white', 'text-blue-600');
                btnLayout.classList.add('text-gray-500', 'hover:bg-gray-200');
            } else {
                btnLayout.classList.add('shadow', 'bg-white', 'text-blue-600');
                btnLayout.classList.remove('text-gray-500', 'hover:bg-gray-200');
                btnAssign.classList.remove('shadow', 'bg-white', 'text-blue-600');
                btnAssign.classList.add('text-gray-500', 'hover:bg-gray-200');
            }
            
            // Hide Spread button (Logic replaced by automatic scaling)
            const btnSpread = document.getElementById('btn-spread');
            btnSpread.classList.add('hidden');

            // Transform Objects dimensions in data model to reflect visual size
            // This ensures drag and drop "center" calculations are correct
            mapObjects.forEach(obj => {
                if (SIZES[obj.type]) {
                    const size = SIZES[obj.type][mode];
                    obj.width = size.w;
                    obj.height = size.h;
                }
            });

            renderAll();
            saveToLocal();
            autoFitZoom(); // Re-center view after coordinate shift
        }

        function toggleSpread() {
            recordState(); // Record before spreading/restoring
            const btn = document.getElementById('btn-spread');
            if (appState.isSpread) {
                // å¾©åŸ (Restore)
                mapObjects.forEach(o => {
                    if (o.ox !== undefined) {
                        o.x = o.ox;
                        o.y = o.oy;
                        delete o.ox;
                        delete o.oy;
                    }
                });
                appState.isSpread = false;
                btn.classList.remove('bg-purple-600', 'text-white');
                btn.classList.add('bg-purple-100', 'text-purple-700');
                btn.innerHTML = '<i class="fa-solid fa-arrows-left-right-to-line"></i> åˆ†æ•£';
            } else {
                // åˆ†æ•£ (Spread)
                // å‚™ä»½åŸå§‹åº§æ¨™
                mapObjects.forEach(o => {
                    o.ox = o.x;
                    o.oy = o.y;
                });
                resolveOverlaps();
                appState.isSpread = true;
                btn.classList.remove('bg-purple-100', 'text-purple-700');
                btn.classList.add('bg-purple-600', 'text-white');
                btn.innerHTML = '<i class="fa-solid fa-rotate-left"></i> å¾©åŸ';
            }
            renderAll();
            saveToLocal();
        }

        function resolveOverlaps() {
            const padding = 20;
            const snapThreshold = 10; // å¸é™„é–¾å€¼ï¼šè‹¥è»¸å‘åå·®å°æ–¼æ­¤å€¼ï¼Œå¼·åˆ¶å°é½Š
            // ç°¡å–®çš„è¿­ä»£å¼ç¢°æ’è™•ç†
            for(let k=0; k<50; k++) {
                let adjusted = false;
                for(let i=0; i<mapObjects.length; i++) {
                    for(let j=i+1; j<mapObjects.length; j++) {
                        let a = mapObjects[i], b = mapObjects[j];
                        let acx = a.x + a.width/2, acy = a.y + a.height/2;
                        let bcx = b.x + b.width/2, bcy = b.y + b.height/2;
                        let dx = acx - bcx, dy = acy - bcy;
                        let minW = (a.width + b.width)/2 + padding;
                        let minH = (a.height + b.height)/2 + padding;
                        
                        if (Math.abs(dx) < minW && Math.abs(dy) < minH) {
                            adjusted = true;
                            
                            // æ™ºæ…§å¸é™„ï¼šå¦‚æœè»¸å‘åå·®å¾ˆå°ï¼Œå¼·åˆ¶å°é½Šè©²è»¸ï¼Œä¸¦åªåœ¨å¦ä¸€è»¸æ¨é–‹
                            if (Math.abs(dx) < snapThreshold) {
                                // å‚ç›´å°é½Š (Xè»¸ç›¸åŒ) -> å¼·åˆ¶å°é½Š Xï¼Œæ¨é–‹ Y
                                const avgCx = (acx + bcx) / 2;
                                a.x = avgCx - a.width/2;
                                b.x = avgCx - b.width/2;
                                
                                let penY = minH - Math.abs(dy);
                                let sign = dy > 0 ? 1 : -1; if(dy===0) sign = 1;
                                a.y += sign * penY * 0.5; b.y -= sign * penY * 0.5;
                            } else if (Math.abs(dy) < snapThreshold) {
                                // æ°´å¹³å°é½Š (Yè»¸ç›¸åŒ) -> å¼·åˆ¶å°é½Š Yï¼Œæ¨é–‹ X
                                const avgCy = (acy + bcy) / 2;
                                a.y = avgCy - a.height/2;
                                b.y = avgCy - b.height/2;
                                
                                let penX = minW - Math.abs(dx);
                                let sign = dx > 0 ? 1 : -1; if(dx===0) sign = 1;
                                a.x += sign * penX * 0.5; b.x -= sign * penX * 0.5;
                            } else {
                                let penX = minW - Math.abs(dx), penY = minH - Math.abs(dy);
                                if (penX < penY) {
                                    let sign = dx > 0 ? 1 : -1; if(dx===0) sign = Math.random()>0.5?1:-1;
                                    a.x += sign * penX * 0.5; b.x -= sign * penX * 0.5;
                                } else {
                                    let sign = dy > 0 ? 1 : -1; if(dy===0) sign = Math.random()>0.5?1:-1;
                                    a.y += sign * penY * 0.5; b.y -= sign * penY * 0.5;
                                }
                            }
                        }
                    }
                }
                if(!adjusted) break;
            }
        }

        function saveToLocal() {
            localStorage.setItem('seatingMasterData', JSON.stringify({ mapObjects, guests, appState }));
            const s = document.getElementById('saveStatus');
            s.innerText = "å·²å„²å­˜ " + new Date().toLocaleTimeString();
            s.classList.add('text-green-600');
            setTimeout(() => s.classList.remove('text-green-600'), 1000);
        }

        function loadFromLocal() {
            const raw = localStorage.getItem('seatingMasterData');
            if (raw) {
                try {
                    const data = JSON.parse(raw);
                    mapObjects = data.mapObjects || [];
                    guests = data.guests || [];
                    if(data.appState) {
                        appState.scale = data.appState.scale || 1;
                        appState.panX = data.appState.panX || 0;
                        appState.panY = data.appState.panY || 0;
                        if(data.appState.viewMode) setViewMode(data.appState.viewMode);
                        if(data.appState.toolMode) setTool(data.appState.toolMode);
                        if(data.appState.snapToGrid !== undefined) {
                            appState.snapToGrid = data.appState.snapToGrid;
                            const cb = document.getElementById('snapGrid'); if(cb) cb.checked = appState.snapToGrid;
                        }
                    }
                } catch(e) { console.error(e); }
            } else {
                addMapObject('stage', -200, -100); // Center stage (width 400) at x=0
                generateGridTables();
            }
        }

        function resetData() {
            if(confirm('æ¸…ç©ºæ‰€æœ‰è³‡æ–™ï¼Ÿ')) {
                localStorage.removeItem('seatingMasterData');
                location.reload();
            }
        }

        // --- Core Logic ---
        function genId() { return Date.now().toString(36) + Math.random().toString(36).substr(2, 5); }

        function addMapObject(type, x, y, isBatch = false) {
            if(!isBatch) recordState();
            if (x === undefined) {
                // Spawn at center of view (0,0 relative to layer origin + pan)
                x = -appState.panX / appState.scale;
                y = -appState.panY / appState.scale;
            }
            const id = genId();
            let newObj = { id, type, x, y, width: 180, height: 180, name: '' };

            if (SIZES[type]) {
                // Use size based on current mode
                const size = SIZES[type][appState.viewMode];
                newObj.width = size.w;
                newObj.height = size.h;
                if (type === 'table') newObj.name = `ç¬¬ ${mapObjects.filter(o=>o.type==='table').length + 1} æ¡Œ`;
                else newObj.name = 'ä¸»æ¡Œ';
            } else if (type === 'stage') {
                newObj.name = 'èˆ å° STAGE'; newObj.width = 400; newObj.height = 60;
            } else if (type === 'label') {
                newObj.name = 'å…¥å£è™•'; newObj.width = 120; newObj.height = 40;
            }
            mapObjects.push(newObj);
            
            if (appState.viewMode === 'assign') {
                const cx = newObj.x + newObj.width / 2;
                const cy = newObj.y + newObj.height / 2;
                const lw = SIZES[type] ? SIZES[type].layout.w : newObj.width;
                const lh = SIZES[type] ? SIZES[type].layout.h : newObj.height;
                newObj.ox = (cx / ASSIGN_SCALE) - lw / 2;
                newObj.oy = (cy / ASSIGN_SCALE) - lh / 2;
            }

            if(!isBatch) {
                renderAll();
                saveToLocal();
            }
            return newObj;
        }

        function generateGridTables() {
            recordState();
            const cols = parseInt(document.getElementById('colsInput').value) || 4;
            const rows = parseInt(document.getElementById('rowsInput').value) || 3;
            const gap = parseInt(document.getElementById('gapInput').value) || 120;
            
            let startY = 50;
            mapObjects.forEach(o => { if(o.y + o.height > startY) startY = o.y + o.height + 50; });
            let count = mapObjects.filter(o => o.type === 'table').length + 1;

            // Default to Layout mode when generating for better packing
            setViewMode('layout');

            for (let r = 0; r < rows; r++) {
                // Center the grid horizontally around 0
                const startX = -(cols * gap) / 2 + gap/2;
                for (let c = 0; c < cols; c++) {
                    let obj = addMapObject('table', startX + c * gap, startY + r * gap, true);
                    obj.name = `ç¬¬ ${count++} æ¡Œ`;
                }
            }
            renderAll();
            autoFitZoom();
            saveToLocal();
        }

        function deleteObject(id) {
            if(!confirm('ç¢ºå®šåˆªé™¤ï¼Ÿ')) return;
            recordState();
            
            // Determine IDs to delete (handle batch delete via selection or single delete)
            const idsToDelete = (id && appState.selectedIds.includes(id)) ? appState.selectedIds : (id ? [id] : appState.selectedIds);
            if(idsToDelete.length === 0) return;

            guests.forEach(g => { if(idsToDelete.includes(g.tableId)) g.tableId = null; });
            mapObjects = mapObjects.filter(o => !idsToDelete.includes(o.id));
            appState.selectedIds = [];
            updateSelectionVisuals();
            renderAll(); updateStats();
        }

        // --- Rendering ---
        function renderAll() { renderUnseatedList(); renderMap(); updateSelectionVisuals(); }

        function renderMap() {
            const container = document.getElementById('transformLayer');
            container.innerHTML = '';

            // --- Draw Grid & Axes ---
            container.innerHTML += `
                <div class="grid-background"></div>
                <div class="axis-line axis-x"></div>
                <div class="axis-line axis-y"></div>
                <div class="origin-label">0,0</div>
            `;

            mapObjects.forEach(obj => {
                const el = document.createElement('div');
                el.className = 'draggable-item';
                el.style.left = obj.x + 'px';
                el.style.top = obj.y + 'px';
                el.style.width = obj.width + 'px';
                el.style.height = obj.height + 'px';
                el.id = obj.id;

                if (!appState.locked) { addDragLogic(el, obj); el.style.cursor = 'move'; } 
                else { el.style.cursor = 'default'; }

                if (obj.type === 'table' || obj.type === 'main-table') {
                    const isMain = obj.type === 'main-table';
                    const isLayout = appState.viewMode === 'layout';
                    const seatedCount = guests.filter(g => g.tableId === obj.id).reduce((acc,g) => acc + (g.count||1), 0);

                    // Class Handling
                    el.className += ` table-node mode-${appState.viewMode} ${isMain ? 'type-main' : ''}`;
                    
                    // Content
                    if(isLayout) {
                        // Small Circle Content (Layout Mode)
                        el.innerHTML = `
                            <div class="flex flex-col items-center justify-center h-full pointer-events-none" onclick="openModal('${obj.id}')">
                                <span class="font-bold ${isMain ? 'text-red-800' : 'text-gray-700'} text-sm leading-none">${obj.name}</span>
                                ${!isMain ? `<span class="text-[10px] text-orange-600 font-bold bg-orange-100 px-1 rounded mt-1">${seatedCount}äºº</span>` : ''}
                            </div>
                            ${!appState.locked ? `<button onclick="deleteObject('${obj.id}')" class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full flex items-center justify-center text-[10px] hover:scale-110 pointer-events-auto">Ã—</button>`:''}
                        `;
                    } else {
                        // Large Rect or Main Table Content
                        const header = document.createElement('div');
                        header.className = isMain ? 'mt-4 mb-2 text-center' : 'bg-gray-100 p-2 border-b border-gray-200 flex justify-between items-center cursor-pointer hover:bg-gray-200 transition group';
                        
                        if (isMain) {
                            header.innerHTML = `<span class="text-xl font-bold text-red-800 cursor-pointer" onclick="openModal('${obj.id}')">${obj.name} <i class="fa-solid fa-pen text-xs opacity-50"></i></span>`;
                            const del = document.createElement('button');
                            del.className = 'absolute top-0 right-0 p-2 text-red-400 hover:text-red-600';
                            if(!appState.locked) del.innerHTML = '<i class="fa-solid fa-times"></i>';
                            del.onclick = (e) => { e.stopPropagation(); deleteObject(obj.id); };
                            el.appendChild(del);
                        } else {
                            header.innerHTML = `
                                <div class="flex items-center gap-1 overflow-hidden flex-1" onclick="openModal('${obj.id}')">
                                    <i class="fa-solid fa-pen text-[10px] text-gray-400 group-hover:text-blue-500"></i>
                                    <span class="font-bold text-gray-700 truncate">${obj.name}</span>
                                </div>
                                <div class="flex items-center gap-1">
                                    <span class="bg-blue-100 text-blue-800 text-xs px-2 rounded-full">${seatedCount}</span>
                                    ${!appState.locked ? `<button onclick="deleteObject('${obj.id}')" class="text-gray-300 hover:text-red-500 px-1"><i class="fa-solid fa-trash-can"></i></button>` : ''}
                                </div>
                            `;
                        }
                        el.appendChild(header);

                        const guestBox = document.createElement('div');
                        guestBox.className = 'flex-1 w-full overflow-y-auto p-1 space-y-1 ' + (isMain ? 'px-4 pb-4' : 'bg-white');
                        guestBox.addEventListener('wheel', e => e.stopPropagation(), {passive:false});

                        const tableGuests = guests.filter(g => g.tableId === obj.id);
                        tableGuests.forEach(g => {
                            guestBox.appendChild(createGuestElement(g, true));
                        });
                        el.appendChild(guestBox);
                    }

                    // Drop Events (Work in both modes, but logic easier in Assign mode)
                    el.addEventListener('dragover', e => e.preventDefault());
                    el.addEventListener('drop', e => dropGuest(e, obj.id));
                    el.addEventListener('dragenter', () => el.classList.add('drag-over'));
                    el.addEventListener('dragleave', () => el.classList.remove('drag-over'));

                } else {
                    // Stage / Label
                    el.className += (obj.type === 'stage' ? ' obj-stage' : ' obj-label');
                    el.innerHTML = `<span onclick="openModal('${obj.id}')" class="cursor-pointer hover:underline decoration-dashed">${obj.name}</span>`;
                    if (!appState.locked) {
                        const del = document.createElement('div');
                        del.className = 'absolute -top-2 -right-2 w-5 h-5 bg-red-500 text-white rounded-full flex items-center justify-center text-xs cursor-pointer shadow hover:scale-110 pointer-events-auto';
                        del.innerHTML = 'Ã—';
                        del.onclick = (e) => { e.stopPropagation(); deleteObject(obj.id); };
                        el.appendChild(del);
                    }
                }
                container.appendChild(el);
            });
        }

        function updateSelectionVisuals() {
            document.querySelectorAll('.draggable-item').forEach(el => el.classList.remove('selected-obj'));
            appState.selectedIds.forEach(id => {
                const el = document.getElementById(id);
                if(el) el.classList.add('selected-obj');
            });
            // Show/Hide Toolbar
            const tb = document.getElementById('alignToolbar');
            if(appState.selectedIds.length > 1) tb.classList.remove('hidden');
            else tb.classList.add('hidden');
        }

        // --- Interaction Logic ---
        function addDragLogic(el, obj) {
            let isDragging = false;
            let startX, startY;
            let initialPos = {}; // Store initial positions for all selected objects
            let dragElements = {}; // Cache DOM elements for performance
            let preDragState = null; // Snapshot for undo

            el.addEventListener('mousedown', e => {
                if (e.target.closest('.guest-chip') || e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
                if (appState.isSpaceDown) return; // Allow bubble to canvas for panning
                e.stopPropagation();

                // Selection Logic
                if (appState.toolMode === 'select') {
                    if (e.shiftKey) {
                        // Toggle/Add
                        if (!appState.selectedIds.includes(obj.id)) appState.selectedIds.push(obj.id);
                    } else {
                        // If clicking an unselected item, clear others. If clicking a selected item, keep selection (for drag)
                        if (!appState.selectedIds.includes(obj.id)) {
                            appState.selectedIds = [obj.id];
                        }
                    }
                    updateSelectionVisuals();
                }

                isDragging = true;
                startX = e.clientX; startY = e.clientY;
                
                // Snapshot positions of ALL selected objects
                appState.selectedIds.forEach(id => {
                    const o = mapObjects.find(i => i.id === id);
                    if(o) initialPos[id] = { x: o.x, y: o.y };

                    // Cache element and disable transition forcefully
                    const elRef = document.getElementById(id);
                    if(elRef) {
                        dragElements[id] = elRef;
                        elRef.style.setProperty('transition', 'none', 'important');
                        elRef.style.zIndex = 100;
                    }
                });
                
                preDragState = JSON.stringify({ mapObjects, guests }); // Capture state before move
            });

            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                e.preventDefault();
                let dx = (e.clientX - startX) / appState.scale;
                let dy = (e.clientY - startY) / appState.scale;
                
                if (e.shiftKey) {
                    if (Math.abs(dx) > Math.abs(dy)) dy = 0;
                    else dx = 0;
                }

                // Snap to Grid Logic (Based on the primary object being dragged)
                if (appState.snapToGrid && initialPos[obj.id]) {
                    const grid = 40; // Match CSS grid size
                    
                    // Calculate target center
                    const currentX = initialPos[obj.id].x + dx;
                    const currentY = initialPos[obj.id].y + dy;
                    const centerX = currentX + obj.width / 2;
                    const centerY = currentY + obj.height / 2;

                    // Snap center to grid intersection
                    const snappedCenterX = Math.round(centerX / grid) * grid;
                    const snappedCenterY = Math.round(centerY / grid) * grid;
                    
                    // Convert back to top-left and recalculate dx/dy
                    dx = (snappedCenterX - obj.width / 2) - initialPos[obj.id].x;
                    dy = (snappedCenterY - obj.height / 2) - initialPos[obj.id].y;
                }
                
                // Move ALL selected objects
                appState.selectedIds.forEach(id => {
                    const o = mapObjects.find(i => i.id === id);
                    const elRef = dragElements[id]; // Use cached element
                    if (o && initialPos[id] && elRef) {
                        o.x = initialPos[id].x + dx;
                        o.y = initialPos[id].y + dy;
                        elRef.style.left = o.x + 'px';
                        elRef.style.top = o.y + 'px';
                    }
                });
            });

            window.addEventListener('mouseup', (e) => { 
                if(isDragging) { 
                    isDragging=false; 
                    el.style.zIndex=''; 
                    
                    // Update ox/oy if moved in Assign Mode
                    if (appState.viewMode === 'assign') {
                         appState.selectedIds.forEach(id => {
                            const o = mapObjects.find(i => i.id === id);
                            if (o) { 
                                const cx = o.x + o.width / 2;
                                const cy = o.y + o.height / 2;
                                const lw = SIZES[o.type] ? SIZES[o.type].layout.w : o.width;
                                const lh = SIZES[o.type] ? SIZES[o.type].layout.h : o.height;
                                o.ox = (cx / ASSIGN_SCALE) - lw / 2;
                                o.oy = (cy / ASSIGN_SCALE) - lh / 2;
                            }
                         });
                    }

                    // Only record history if actually moved
                    if (Math.abs(e.clientX - startX) > 2 || Math.abs(e.clientY - startY) > 2) {
                        historyStack.push(preDragState); // Push the PRE-DRAG state to undo stack
                        if (historyStack.length > 50) historyStack.shift();
                        redoStack = [];
                        updateHistoryButtons();
                        saveToLocal(); 
                    }
                } 
            });
        }

        // --- Guest Logic ---
        function parseGuests() {
            recordState();
            const input = document.getElementById('guestInput').value;
            const defUnit = document.getElementById('defaultUnitInput').value.trim() || 'è²´è³“';
            const mode = document.querySelector('input[name="inputMode"]:checked').value;
            
            if(!input.trim()) return;
            const lines = input.split('\n');
            
            lines.forEach(line => {
                line = line.trim().replace(/ï¼š/g, ':').replace(/ï¼Œ/g, ',');
                if(!line) return;
                if (line.includes(':')) {
                    const [unit, names] = line.split(':');
                    names.split(/,| /).forEach(n => { if(n.trim()) addGuest(unit.trim(), n.trim()); });
                } else if (line.match(/^(.+?)\s+(\d+)$/)) {
                    const match = line.match(/^(.+?)\s+(\d+)$/);
                    const label = match[1];
                    const num = parseInt(match[2]);
                    if (mode === 'unit') addGuest(label, "ä¿ç•™å¸­", num);
                    else addGuest(defUnit, label, num);
                } else {
                    const parts = line.split(/\s+/);
                    if (parts.length >= 2) addGuest(parts[0], parts.slice(1).join(' '));
                    else if (parts.length === 1) {
                        if (mode === 'unit') addGuest(parts[0], "ä¿ç•™å¸­");
                        else addGuest(defUnit, parts[0]);
                    }
                }
            });
            document.getElementById('guestInput').value = '';
            renderAll(); updateStats(); saveToLocal();
        }

        function addGuest(unit, name, count=1) { guests.push({ id: genId(), unit, name, count, tableId: null }); }

        function renderUnseatedList() {
            const list = document.getElementById('unseatedList'); list.innerHTML = '';
            guests.filter(g => !g.tableId).forEach(g => list.appendChild(createGuestElement(g, false)));
        }

        function createGuestElement(g, seated) {
            const el = document.createElement('div');
            el.className = `guest-chip bg-white border rounded p-1 text-xs flex justify-between items-center group relative ${seated ? 'border-blue-200' : 'border-gray-200'}`;
            el.draggable = true;
            el.innerHTML = `
                <div class="pointer-events-none truncate pr-4">
                    <span class="text-gray-400 text-[10px] mr-1">${g.unit}</span>
                    <span class="font-bold text-gray-700">${g.name}</span>
                    ${g.count > 1 ? `<span class="ml-1 bg-red-500 text-white rounded-full px-1 text-[9px]">x${g.count}</span>` : ''}
                </div>
                <button onclick="removeGuest('${g.id}')" class="absolute right-1 text-gray-300 hover:text-red-500"><i class="fa-solid fa-times"></i></button>
            `;
            el.addEventListener('dragstart', ev => { ev.dataTransfer.setData('gid', g.id); el.classList.add('dragging'); });
            el.addEventListener('dragend', () => el.classList.remove('dragging'));
            return el;
        }

        function dropGuest(ev, tableId) {
            ev.preventDefault();
            recordState();
            document.querySelectorAll('.drag-over').forEach(e => e.classList.remove('drag-over'));
            const gid = ev.dataTransfer.getData('gid');
            const guest = guests.find(g => g.id === gid);
            if (guest) { guest.tableId = tableId; renderAll(); updateStats(); saveToLocal(); }
        }

        function removeGuest(id) {
            if(confirm('åˆªé™¤?')) { recordState(); guests = guests.filter(g => g.id !== id); renderAll(); updateStats(); saveToLocal(); }
        }

        function updateStats() {
            const total = guests.reduce((sum, g) => sum + (g.count || 1), 0);
            const seated = guests.filter(g => g.tableId).reduce((sum, g) => sum + (g.count || 1), 0);
            document.getElementById('totalCount').innerText = total;
            document.getElementById('seatedCount').innerText = seated;
            document.getElementById('unseatedCount').innerText = total - seated;
        }

        // --- Canvas Events ---
        function setupCanvasEvents() {
            const canvas = document.getElementById('floorCanvas');
            const marquee = document.getElementById('selectionMarquee');
            let isPanning = false, startX = 0, startY = 0;
            let initialPanX = 0, initialPanY = 0;
            let isSelecting = false, selStartX = 0, selStartY = 0;
            let canvasRect = null;

            canvas.addEventListener('mousedown', e => {
                if(e.target === canvas || e.target.id === 'transformLayer') {
                    if (appState.toolMode === 'pan' || (appState.toolMode === 'select' && e.button === 1) || appState.isSpaceDown) {
                        // Pan Mode
                        isPanning = true; startX = e.clientX - appState.panX; startY = e.clientY - appState.panY;
                        initialPanX = appState.panX; initialPanY = appState.panY;
                        canvas.style.cursor = 'grabbing';
                    } else if (appState.toolMode === 'select' && !appState.locked && !appState.isSpaceDown) {
                        // Select Mode (Marquee)
                        isSelecting = true;
                        canvasRect = canvas.getBoundingClientRect();
                        selStartX = e.clientX - canvasRect.left; 
                        selStartY = e.clientY - canvasRect.top;
                        
                        marquee.style.display = 'block';
                        marquee.style.left = selStartX + 'px'; marquee.style.top = selStartY + 'px';
                        marquee.style.width = '0px'; marquee.style.height = '0px';
                        
                        // Clear selection if not holding shift
                        if(!e.shiftKey) {
                            appState.selectedIds = [];
                            updateSelectionVisuals();
                        }
                    }
                }
            });
            window.addEventListener('mousemove', e => {
                if(isPanning) { appState.panX = e.clientX - startX; appState.panY = e.clientY - startY; updateTransform(); }
                if(isSelecting) {
                    const currentX = e.clientX - canvasRect.left; 
                    const currentY = e.clientY - canvasRect.top;
                    const left = Math.min(selStartX, currentX);
                    const top = Math.min(selStartY, currentY);
                    const width = Math.abs(currentX - selStartX);
                    const height = Math.abs(currentY - selStartY);
                    marquee.style.left = left + 'px'; marquee.style.top = top + 'px';
                    marquee.style.width = width + 'px'; marquee.style.height = height + 'px';
                }
            });
            window.addEventListener('mouseup', (e) => { 
                if(isPanning) { 
                    isPanning = false; canvas.style.cursor = 'grab'; 
                    if(appState.panX !== initialPanX || appState.panY !== initialPanY) saveToLocal();
                }
                if(isSelecting) {
                    isSelecting = false; marquee.style.display = 'none';
                    const currentX = e.clientX - canvasRect.left;
                    const currentY = e.clientY - canvasRect.top;
                    finishSelection(selStartX, selStartY, currentX, currentY, e.shiftKey);
                    canvasRect = null;
                }
            });
            canvas.addEventListener('wheel', e => {
                e.preventDefault(); const delta = e.deltaY > 0 ? 0.9 : 1.1;
                appState.scale = Math.max(0.1, Math.min(5, appState.scale * delta)); updateTransform();
            });
        }

        function finishSelection(x1, y1, x2, y2, isShift) {
            // Convert screen rect to world rect
            const left = Math.min(x1, x2); const top = Math.min(y1, y2);
            const right = Math.max(x1, x2); const bottom = Math.max(y1, y2);
            
            // If click without drag (tiny movement), clear selection
            if (Math.abs(x2-x1) < 5 && Math.abs(y2-y1) < 5) {
                if(!isShift) appState.selectedIds = [];
                updateSelectionVisuals();
                return;
            }
            
            const canvas = document.getElementById('floorCanvas');
            const centerX = canvas.clientWidth / 2;
            const centerY = canvas.clientHeight / 2;

            mapObjects.forEach(o => {
                // Object screen coordinates
                const ox = centerX + appState.panX + o.x * appState.scale;
                const oy = centerY + appState.panY + o.y * appState.scale;
                const ow = o.width * appState.scale;
                const oh = o.height * appState.scale;

                // Check intersection
                if (ox < right && ox + ow > left && oy < bottom && oy + oh > top) {
                    if (!appState.selectedIds.includes(o.id)) appState.selectedIds.push(o.id);
                }
            });
            updateSelectionVisuals();
        }

        // --- Alignment Functions ---
        function alignSelected(type) {
            if (appState.selectedIds.length < 2) return;
            recordState();
            const selected = mapObjects.filter(o => appState.selectedIds.includes(o.id));
            
            if (type === 'left') {
                const minX = Math.min(...selected.map(o => o.x));
                selected.forEach(o => o.x = minX);
            } else if (type === 'center-h') {
                const minX = Math.min(...selected.map(o => o.x));
                const maxX = Math.max(...selected.map(o => o.x + o.width));
                const center = (minX + maxX) / 2;
                selected.forEach(o => o.x = center - o.width / 2);
            } else if (type === 'right') {
                const maxRight = Math.max(...selected.map(o => o.x + o.width));
                selected.forEach(o => o.x = maxRight - o.width);
            } else if (type === 'top') {
                const minY = Math.min(...selected.map(o => o.y));
                selected.forEach(o => o.y = minY);
            } else if (type === 'center-v') {
                const minY = Math.min(...selected.map(o => o.y));
                const maxY = Math.max(...selected.map(o => o.y + o.height));
                const center = (minY + maxY) / 2;
                selected.forEach(o => o.y = center - o.height / 2);
            } else if (type === 'bottom') {
                const maxBottom = Math.max(...selected.map(o => o.y + o.height));
                selected.forEach(o => o.y = maxBottom - o.height);
            }
            renderAll(); saveToLocal();
        }

        function distributeSelected(type) {
            if (appState.selectedIds.length < 3) return;
            recordState();
            const selected = mapObjects.filter(o => appState.selectedIds.includes(o.id));
            
            if (type === 'h') {
                selected.sort((a, b) => a.x - b.x);
                const minX = selected[0].x;
                const maxX = selected[selected.length - 1].x + selected[selected.length - 1].width;
                const totalWidth = maxX - minX;
                const sumObjectWidth = selected.reduce((sum, o) => sum + o.width, 0);
                const gap = (totalWidth - sumObjectWidth) / (selected.length - 1);
                
                let currentX = minX;
                selected.forEach(o => {
                    o.x = currentX;
                    currentX += o.width + gap;
                });
            } else if (type === 'v') {
                selected.sort((a, b) => a.y - b.y);
                const minY = selected[0].y;
                const maxY = selected[selected.length - 1].y + selected[selected.length - 1].height;
                const totalHeight = maxY - minY;
                const sumObjectHeight = selected.reduce((sum, o) => sum + o.height, 0);
                const gap = (totalHeight - sumObjectHeight) / (selected.length - 1);
                
                let currentY = minY;
                selected.forEach(o => {
                    o.y = currentY;
                    currentY += o.height + gap;
                });
            }
            renderAll(); saveToLocal();
        }

        function arrangeSelectedGrid() {
            if (appState.selectedIds.length < 2) return;
            recordState();
            const selected = mapObjects.filter(o => appState.selectedIds.includes(o.id));
            
            // 1. Sort spatially to determine logical order
            // Heuristic: Sort by Y first (grouping by row threshold), then by X.
            const avgH = selected.reduce((s,o)=>s+o.height,0) / selected.length;
            const threshold = avgH * 0.5;

            selected.sort((a,b) => a.y - b.y);
            
            const rows = [];
            let currentRow = [selected[0]];
            let currentRowY = selected[0].y;

            for(let i=1; i<selected.length; i++) {
                const obj = selected[i];
                if (Math.abs(obj.y - currentRowY) < threshold) {
                    currentRow.push(obj);
                } else {
                    rows.push(currentRow);
                    currentRow = [obj];
                    currentRowY = obj.y;
                }
            }
            rows.push(currentRow);
            rows.forEach(r => r.sort((a,b) => a.x - b.x));
            const sorted = rows.flat();

            // 2. Prompt Settings
            const defaultCols = Math.max(...rows.map(r => r.length));
            const colsStr = prompt(`æ’åˆ—æˆå¹¾åˆ— (Columns)?\n(é¸å–äº† ${selected.length} å€‹ç‰©ä»¶)`, defaultCols);
            if (!colsStr) return;
            const cols = parseInt(colsStr);
            if (isNaN(cols) || cols < 1) return;

            const gapStr = prompt("é–“è· (Gap)?", "120");
            const gap = parseInt(gapStr) || 120;

            // 3. Arrange
            const minX = Math.min(...selected.map(o => o.x));
            const minY = Math.min(...selected.map(o => o.y));

            sorted.forEach((obj, index) => {
                const c = index % cols;
                const r = Math.floor(index / cols);
                obj.x = minX + c * gap;
                obj.y = minY + r * gap;
            });

            renderAll(); saveToLocal();
        }

        function updateTransform() {
            document.getElementById('transformLayer').style.transform = `translate(${appState.panX}px, ${appState.panY}px) scale(${appState.scale})`;
            document.getElementById('zoomLevelDisplay').innerText = Math.round(appState.scale * 100) + '%';
        }
        function zoomIn() { appState.scale *= 1.2; updateTransform(); saveToLocal(); }
        function zoomOut() { appState.scale *= 0.8; updateTransform(); saveToLocal(); }
        function autoFitZoom() {
            if(mapObjects.length === 0) return;
            const xs = mapObjects.map(o => o.x); const ys = mapObjects.map(o => o.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs) + 180;
            const minY = Math.min(...ys), maxY = Math.max(...ys) + 180;
            const cvs = document.getElementById('floorCanvas');
            const s = Math.min((cvs.clientWidth-100)/(maxX-minX), (cvs.clientHeight-100)/(maxY-minY), 1.5);
            appState.scale = Math.max(0.2, s);
            // Center the view on the center of the objects
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            appState.panX = -cx * appState.scale;
            appState.panY = -cy * appState.scale;
            updateTransform();
            saveToLocal();
        }

        // --- Modals ---
        function toggleLock() {
            appState.locked = !appState.locked;
            document.getElementById('lockLayout').checked = appState.locked;
            document.getElementById('lockLabel').innerText = appState.locked ? "ğŸ”’ å·²é–å®š" : "ğŸ”“ è§£é–ç·¨è¼¯";
            saveToLocal();
            renderMap();
        }
        function toggleSnap() {
            appState.snapToGrid = !appState.snapToGrid;
            document.getElementById('snapGrid').checked = appState.snapToGrid;
            saveToLocal();
        }
        function openModal(id) {
            editingObjectId = id;
            document.getElementById('modalInput').value = mapObjects.find(o => o.id === id).name;
            document.getElementById('modalOverlay').classList.remove('hidden');
            setTimeout(() => document.getElementById('modalInput').focus(), 50);
        }
        function closeModal() { document.getElementById('modalOverlay').classList.add('hidden'); }
        function saveModal() {
            recordState();
            const name = document.getElementById('modalInput').value.trim();
            if(name) { mapObjects.find(o => o.id === editingObjectId).name = name; renderMap(); saveToLocal(); }
            closeModal();
        }
        function switchTab(t) {
            ['tab-guests', 'tab-layout'].forEach(id => {
                document.getElementById(id).classList.add('hidden');
                document.getElementById('btn-'+id).classList.remove('border-blue-600', 'bg-blue-50', 'text-blue-600');
            });
            document.getElementById(t).classList.remove('hidden');
            document.getElementById('btn-'+t).classList.add('border-blue-600', 'bg-blue-50', 'text-blue-600');
        }

        // --- Export Excel ---
        function exportExcel() {
            if(guests.length === 0) return alert('ç„¡åå–®');
            const data = [];
            const seated = guests.filter(g=>g.tableId), unseated = guests.filter(g=>!g.tableId);
            seated.sort((a,b) => {
                const ta = mapObjects.find(o=>o.id===a.tableId), tb = mapObjects.find(o=>o.id===b.tableId);
                return (ta?parseInt(ta.name.replace(/\D/g,''))||0:999) - (tb?parseInt(tb.name.replace(/\D/g,''))||0:999);
            });
            seated.concat(unseated).forEach(g => {
                const t = mapObjects.find(o => o.id === g.tableId);
                data.push({ "æ¡Œè™Ÿ": t?t.name:"-", "å–®ä½": g.unit, "å§“å": g.name, "äººæ•¸": g.count, "ç‹€æ…‹": t?"å·²å…¥å¸­":"æœªå…¥å¸­" });
            });
            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "åå–®");
            XLSX.writeFile(wb, "æ´»å‹•åå–®.xlsx");
        }

        // --- Export PDF (Vector via System Print) ---
        function exportPDF() {
            if (appState.viewMode !== 'assign') {
                alert('è«‹å…ˆåˆ‡æ›è‡³ã€Œæ’ä½æ¨¡å¼ (å¤§)ã€å†é€²è¡Œ PDF è¼¸å‡ºï¼Œä»¥ç¢ºä¿ç‰ˆé¢èˆ‡å…§å®¹æ­£ç¢ºã€‚');
                return;
            }
            
            // 1. Create Print Container
            const container = document.createElement('div');
            container.id = 'print-container';
            container.style.display = 'none';
            
            const content = document.createElement('div');
            content.id = 'print-content';
            container.appendChild(content);

            // 2. Calculate Bounds to determine relative positioning
            const xs = mapObjects.map(o => o.x);
            const ys = mapObjects.map(o => o.y);
            const minX = Math.min(...xs);
            const minY = Math.min(...ys);
            const maxX = Math.max(...xs.map((x, i) => x + mapObjects[i].width));
            const maxY = Math.max(...ys.map((y, i) => y + mapObjects[i].height));
            
            const padding = 50;
            const width = maxX - minX + padding * 2;
            const height = maxY - minY + padding * 2;
            
            content.style.width = width + 'px';
            content.style.height = height + 'px';
            
            // Calculate Scale to fit A4 Landscape (approx 1123x794px at 96dpi)
            // Use a slightly smaller area to ensure margins
            const A4_WIDTH = 1080; 
            const A4_HEIGHT = 750;
            
            const scaleX = A4_WIDTH / width;
            const scaleY = A4_HEIGHT / height;
            const scale = Math.min(scaleX, scaleY); 
            
            content.style.transform = `translate(-50%, -50%) scale(${scale})`;

            mapObjects.forEach(obj => {
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.left = (obj.x - minX + padding) + 'px';
                el.style.top = (obj.y - minY + padding) + 'px';
                el.style.width = obj.width + 'px';
                
                if (obj.type === 'table' || obj.type === 'main-table') {
                    el.style.height = 'auto'; // Auto height to fit all guests
                    el.style.minHeight = obj.height + 'px';
                    el.className = obj.type === 'main-table' 
                        ? 'bg-red-50 border-2 border-red-500 rounded-xl shadow-sm flex flex-col overflow-hidden text-red-800 print-color-adjust'
                        : 'bg-white border-2 border-gray-300 rounded-xl shadow-sm flex flex-col overflow-hidden print-color-adjust';

                    const seatedCount = guests.filter(g => g.tableId === obj.id).reduce((acc,g) => acc + (g.count||1), 0);
                    
                    // Header
                    const header = document.createElement('div');
                    header.className = obj.type === 'main-table' ? 'p-2 text-center font-bold text-lg border-b border-red-200' : 'p-2 bg-gray-100 border-b border-gray-200 flex justify-between items-center';
                    header.innerHTML = obj.type === 'main-table' ? obj.name : `<span class="font-bold text-gray-700">${obj.name}</span><span class="bg-blue-100 text-blue-800 text-xs px-2 rounded-full print-color-adjust">${seatedCount}</span>`;
                    el.appendChild(header);

                    // Guest List with Multi-column
                    const list = document.createElement('div');
                    list.className = 'p-2 text-xs';
                    list.style.columnCount = 2; // Force 2 columns
                    list.style.columnGap = '0.5rem';
                    
                    guests.filter(g => g.tableId === obj.id).forEach(g => {
                        const item = document.createElement('div');
                        item.className = 'mb-1 break-inside-avoid flex items-center'; // Prevent split
                        item.innerHTML = `<span class="text-gray-500 mr-1 scale-90 origin-left">${g.unit}</span><span class="font-bold">${g.name}</span>${g.count > 1 ? `<span class="ml-1 text-red-500">x${g.count}</span>` : ''}`;
                        list.appendChild(item);
                    });
                    el.appendChild(list);
                } else {
                    el.style.height = obj.height + 'px';
                    el.className = obj.type === 'stage' ? 'bg-blue-500 text-white flex items-center justify-center font-bold rounded shadow opacity-90 print-color-adjust' : 'bg-gray-200 border border-gray-400 text-gray-600 flex items-center justify-center font-bold rounded-full print-color-adjust';
                    el.innerText = obj.name;
                }
                content.appendChild(el);
            });

            document.body.appendChild(container);

            // 3. Trigger Print
            // The browser's print dialog will open. User can choose "Save as PDF".
            window.print();

            // 4. Cleanup
            document.body.removeChild(container);
        }

        // --- Export Web Package (Small Circle Mode Forced) ---
        async function exportWebPackage() {
            if(mapObjects.length === 0) return alert('å ´åœ°æ˜¯ç©ºçš„');

            // Force prepare data as if we are in layout mode (small circles)
            // Even if user is currently in Assign mode, we use width=80 for export calculation
            const exportData = {
                date: new Date().toISOString().split('T')[0],
                objects: mapObjects.map(o => ({
                    id: o.id, type: o.type,
                    // If it's a table, we export it as a small circle (80px), using center point of current position
                    // We assume current x,y is top-left. 
                    // To keep visual center consistent if coming from Large mode:
                    //   Center = x + w/2. New X = Center - NewW/2.
                    // But to keep it simple, we trust the Layout Mode arrangement.
                    // å¦‚æœè™•æ–¼åˆ†æ•£æ¨¡å¼ï¼ŒåŒ¯å‡ºæ™‚ä½¿ç”¨åŸå§‹åº§æ¨™ (ox, oy)
                    x: Math.round(o.ox !== undefined ? o.ox : o.x), 
                    y: Math.round(o.oy !== undefined ? o.oy : o.y),
                    w: (o.type==='table') ? 80 : (o.type==='main-table' ? 120 : o.width),
                    h: (o.type==='table') ? 80 : (o.type==='main-table' ? 120 : o.height),
                    name: o.name
                })),
                guests: guests.filter(g => g.tableId).map(g => ({ unit: g.unit, name: g.name, count: g.count, tableId: g.tableId }))
            };

            const xs = exportData.objects.map(o => o.x); const ys = exportData.objects.map(o => o.y);
            const minX = Math.min(...xs) - 50, maxX = Math.max(...xs) + 200;
            const minY = Math.min(...ys) - 50, maxY = Math.max(...ys) + 200;
            const viewBox = `${minX} ${minY} ${maxX - minX} ${maxY - minY}`;

            try {
                const response = await fetch('template/search_template.html');
                if (!response.ok) throw new Error('ç„¡æ³•è®€å–ç¯„æœ¬æª”æ¡ˆ (template/search_template.html)');
                let htmlContent = await response.text();

                htmlContent = htmlContent.replace('{{DATA_JSON}}', JSON.stringify(exportData));
                htmlContent = htmlContent.replace('{{VIEWBOX}}', viewBox);
                htmlContent = htmlContent.replace('{{UPDATE_DATE}}', exportData.date);

                const blob = new Blob([htmlContent], {type: 'text/html'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `åº§ä½æŸ¥è©¢ç³»çµ±_${exportData.date}.html`;
                a.click();
                URL.revokeObjectURL(url);
            } catch (err) {
                console.error(err);
                alert('åŒ¯å‡ºå¤±æ•—ï¼šç„¡æ³•è®€å–ç¯„æœ¬æª”æ¡ˆã€‚\nè«‹ç¢ºä¿ template/search_template.html å­˜åœ¨ï¼Œä¸”é€é Web Server (http/https) åŸ·è¡Œæ­¤ç¶²é ï¼Œè€Œéç›´æ¥é–‹å•Ÿæª”æ¡ˆ (file://)ã€‚');
            }
        }
    </script>
</body>
</html>